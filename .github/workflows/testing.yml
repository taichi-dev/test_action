name: Build and Test
on:
  pull_request:
    types: [opened, synchronize, reopened]
  push:
    branches: [master]

concurrency:
  group: ${{ github.event.number || github.run_id }}
  cancel-in-progress: true

jobs:
  check_files:
    name: Check files
    # Disable this workflow on forks
    if: github.repository_owner == 'taichi-dev'
    outputs:
      run_job: ${{ steps.check_files.outputs.run_job }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
        with:
          fetch-depth: 2

      - name: check modified files
        id: check_files
        run: |
          echo "Concurrency group: ${{ github.event.number || github.run_id }}"
          echo "=============== list modified files ==============="
          git diff --name-only @^

          chore_files=( LICENSE CONTRIBUTING.md README.md netlify.toml )
          chore_dirs=( docs )
          run_job=false

          for file in $(git diff --name-only @^); do
            is_chore=false

            for chore_file in ${chore_files[*]}; do
              [[ ${file} == ${chore_file} ]] && is_chore=true && break
            done

            for chore_dir in ${chore_dirs[*]}; do
              [[ ${file} == ${chore_dir}/* ]] && is_chore=true && break
            done

            if ! ${is_chore}; then
              run_job=true
              break
            fi
          done

          if ${run_job}; then
            echo "::set-output name=run_job::true"
          else
            echo "::set-output name=run_job::false"
          fi

  build_and_test_cpu_linux:
    name: Build and Test linux (CPU)
    needs: check_files
    timeout-minutes: 60
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            python: py39
            with_cc: ON
            wanted_archs: 'cpu,cc'
    runs-on: ${{ matrix.os }}
    permissions:
      packages: read
      contents: read
    steps:
      - uses: actions/checkout@v2
        with:
          submodules: 'recursive'

      - name: Get sccache cache
        uses: actions/cache@v2
        with:
          path: sccache_cache
          key: sccache-linux-${{matrix.with_cc}}-${{ github.sha }}
          restore-keys: |
            sccache-linux-${{matrix.with_cc}}-

      - name: Get docker images
        run: |
          if [[ ${{needs.check_files.outputs.run_job}} == false ]]; then
            exit 0
          fi
          # https://docs.github.com/en/packages/managing-github-packages-using-github-actions-workflows/publishing-and-installing-a-package-with-github-actions#upgrading-a-workflow-that-accesses-ghcrio
          echo $CR_PAT | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          docker pull ghcr.io/taichi-dev/taichidev-cpu-ubuntu18.04:v0.3.0
        env:
          CR_PAT: ${{ secrets.GITHUB_TOKEN }}

      - name: Build
        run: |
          if [[ ${{needs.check_files.outputs.run_job}} == false ]]; then
            exit 0
          fi
          mkdir -m777 shared
          docker create --user dev --name taichi_build \
            -e PY -e PROJECT_NAME -e TAICHI_CMAKE_ARGS \
            ghcr.io/taichi-dev/taichidev-cpu-ubuntu18.04:v0.3.0 \
            /home/dev/test_actions/.github/workflows/scripts/unix_build.sh
          # A tarball is needed because sccache needs some permissions that only the file owner has.
          # 1000 is the uid and gid of user "dev" in the container.
          # If the uid or gid of the user inside the docker changes, please change the uid and gid in the following line.
          tar -cf - ../${{ github.event.repository.name }} --mode u=+rwx,g=+rwx,o=+rwx --owner 1000 --group 1000 | docker cp - taichi_build:/home/dev/
          docker start -a taichi_build
          rm -rf sccache_cache
          docker cp taichi_build:/home/dev/test_actions/sccache_cache sccache_cache
          docker cp taichi_build:/home/dev/test_actions/dist shared/dist
          docker cp taichi_build:/home/dev/test_actions/build shared/build
        env:
          PY: ${{ matrix.python }}
          PROJECT_NAME: taichi
          TAICHI_CMAKE_ARGS: -DTI_WITH_OPENGL:BOOL=OFF -DTI_WITH_CC:BOOL=${{ matrix.with_cc }} -DTI_WITH_VULKAN:BOOL=OFF -DTI_BUILD_TESTS:BOOL=ON -DCMAKE_C_COMPILER_LAUNCHER=sccache -DCMAKE_CXX_COMPILER_LAUNCHER=sccache

      - name: Test
        run: |
          if [[ ${{needs.check_files.outputs.run_job}} == false ]]; then
            exit 0
          fi
          docker create --user dev --name taichi_test -e PY -e TI_WANTED_ARCHS ghcr.io/taichi-dev/taichidev-cpu-ubuntu18.04:v0.3.0 /home/dev/unix_test.sh
          docker cp .github/workflows/scripts/unix_test.sh taichi_test:/home/dev/unix_test.sh
          docker cp shared/dist/ taichi_test:/home/dev/
          docker cp shared/build/ taichi_test:/home/dev/
          docker cp ./requirements_test.txt taichi_test:/home/dev/requirements_test.txt
          docker cp tests/ taichi_test:/home/dev/
          docker cp pyproject.toml taichi_test:/home/dev/
          docker start -a taichi_test
        env:
          PY: ${{ matrix.python }}
          TI_WANTED_ARCHS: ${{ matrix.wanted_archs }}

      - name: clean docker container
        if: always()
        run: |
          docker rm taichi_build taichi_test -f


  build_and_test_cpu_windows:
    name: Build and Test Windows (CPU)
    needs: check_files
    timeout-minutes: 60
    strategy:
      matrix:
        include:
          - os: windows-2019
            python: py37
            with_cc: OFF
            wanted_archs: 'cpu'
    runs-on: ${{ matrix.os }}
    permissions:
      packages: read
      contents: read
    steps:
      - uses: actions/checkout@v2
        with:
          submodules: 'recursive'

      - name: Get sccache cache
        uses: actions/cache@v2
        with:
          path: sccache_cache
          key: sccache-win64-${{matrix.with_cc}}-${{ github.sha }}
          restore-keys: |
            sccache-win64-${{matrix.with_cc}}-

      - name: Get docker images
        shell: bash
        run: |
          if [[ ${{needs.check_files.outputs.run_job}} == false ]]; then
            exit 0
          fi
          echo $CR_PAT | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          docker pull ghcr.io/taichi-dev/taichidev-cpu-windows:v0.0.1
        env:
          CR_PAT: ${{ secrets.GITHUB_TOKEN }}

      - name: Build
        shell: bash
        run: |
          if [[ ${{needs.check_files.outputs.run_job}} == false ]]; then
            exit 0
          fi
          mkdir shared
          
          docker create --name taichi_build \
            -e PY -e PROJECT_NAME -e TAICHI_CMAKE_ARGS \
            ghcr.io/taichi-dev/taichidev-cpu-windows:v0.0.1 \
            C:/test_actions/.github/workflows/scripts/win_build_cpu.ps1
         
          tar -cf - ../${{ github.event.repository.name }} --mode u=+rwx,g=+rwx,o=+rwx | docker cp - taichi_build:C:/

          docker start -a taichi_build 

          rm -rf sccache_cache
          docker cp taichi_build:C:/taichi/sccache_cache sccache_cache
          docker cp taichi_build:C:/taichi/dist shared/dist
          docker cp taichi_build:C:/taichi/build shared/build
          
        env:
          PY: ${{ matrix.python }}
          PROJECT_NAME: taichi
          TAICHI_CMAKE_ARGS: -DTI_WITH_OPENGL:BOOL=OFF -DTI_WITH_CC:BOOL=${{ matrix.with_cc }} -DTI_WITH_VULKAN:BOOL=OFF -DTI_BUILD_TESTS:BOOL=ON -DCMAKE_C_COMPILER_LAUNCHER=sccache -DCMAKE_CXX_COMPILER_LAUNCHER=sccache


      - name: clean docker container
        if: always()
        run: |
          docker rm taichi_build -f
